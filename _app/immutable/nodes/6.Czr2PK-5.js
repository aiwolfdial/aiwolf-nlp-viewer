var me=Object.defineProperty;var Se=(e,t,r)=>t in e?me(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var d=(e,t,r)=>Se(e,typeof t!="symbol"?t+"":t,r);import{t as ee,a as j}from"../chunks/hEf28_al.js";import{aI as be,u as we,b as ve,k as Ee,e as te,p as _e,a9 as Ae,s as p,c as u,t as X,a as ge,$ as Ke,r as f}from"../chunks/BaJkMvzh.js";import{s as Ce}from"../chunks/DB3GrP0H.js";import{i as Pe}from"../chunks/2lBR0iQD.js";import{l as re,f as He,h as Te}from"../chunks/BznZzeTG.js";import{a as E,r as Z}from"../chunks/n0xSycqS.js";import{i as Re,p as We}from"../chunks/CYlRyKWv.js";/* empty css                */function Q(e,t,r=t){var a=be();re(e,"input",s=>{var n=s?e.defaultValue:e.value;if(n=M(e)?B(n):n,r(n),a&&n!==(n=t())){var o=e.selectionStart,i=e.selectionEnd;e.value=n??"",i!==null&&(e.selectionStart=o,e.selectionEnd=Math.min(i,e.value.length))}}),(Ee&&e.defaultValue!==e.value||we(t)==null&&e.value)&&r(M(e)?B(e.value):e.value),ve(()=>{var s=t();M(e)&&s===B(e.value)||e.type==="date"&&!s&&!e.value||s!==e.value&&(e.value=s??"")})}function M(e){var t=e.type;return t==="number"||t==="range"}function B(e){return e===""?null:+e}function ae(e,t,r){if(e.multiple)return De(e,t);for(var a of e.options){var s=H(a);if(Re(s,t)){a.selected=!0;return}}(!r||t!==void 0)&&(e.selectedIndex=-1)}function xe(e,t){te(()=>{var r=new MutationObserver(()=>{var a=e.__value;ae(e,a)});return r.observe(e,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["value"]}),()=>{r.disconnect()}})}function $e(e,t,r=t){var a=!0;re(e,"change",s=>{var n=s?"[selected]":":checked",o;if(e.multiple)o=[].map.call(e.querySelectorAll(n),H);else{var i=e.querySelector(n)??e.querySelector("option:not([disabled])");o=i&&H(i)}r(o)}),te(()=>{var s=t();if(ae(e,s,a),a&&s===void 0){var n=e.querySelector(":checked");n!==null&&(s=H(n),r(s))}e.__value=s,a=!1}),xe(e)}function De(e,t){for(var r of e.options)r.selected=~t.indexOf(H(r))}function H(e){return"__value"in e?e.__value:e.value}const g=new TextEncoder,O=new TextDecoder;function Oe(...e){const t=e.reduce((s,{length:n})=>s+n,0),r=new Uint8Array(t);let a=0;for(const s of e)r.set(s,a),a+=s.length;return r}function Je(e){if(Uint8Array.prototype.toBase64)return e.toBase64();const t=32768,r=[];for(let a=0;a<e.length;a+=t)r.push(String.fromCharCode.apply(null,e.subarray(a,a+t)));return btoa(r.join(""))}function Ie(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);const t=atob(e),r=new Uint8Array(t.length);for(let a=0;a<t.length;a++)r[a]=t.charCodeAt(a);return r}function Ue(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:O.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=O.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Ie(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}function N(e){let t=e;return typeof t=="string"&&(t=g.encode(t)),Uint8Array.prototype.toBase64?t.toBase64({alphabet:"base64url",omitPadding:!0}):Je(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}class J extends Error{constructor(r,a){var s;super(r,a);d(this,"code","ERR_JOSE_GENERIC");this.name=this.constructor.name,(s=Error.captureStackTrace)==null||s.call(Error,this,this.constructor)}}d(J,"code","ERR_JOSE_GENERIC");class b extends J{constructor(){super(...arguments);d(this,"code","ERR_JOSE_NOT_SUPPORTED")}}d(b,"code","ERR_JOSE_NOT_SUPPORTED");class _ extends J{constructor(){super(...arguments);d(this,"code","ERR_JWS_INVALID")}}d(_,"code","ERR_JWS_INVALID");class se extends J{constructor(){super(...arguments);d(this,"code","ERR_JWT_INVALID")}}d(se,"code","ERR_JWT_INVALID");function h(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function P(e,t){return e.name===t}function L(e){return parseInt(e.name.slice(4),10)}function Me(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function Be(e,t){if(!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function Ne(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!P(e.algorithm,"HMAC"))throw h("HMAC");const a=parseInt(t.slice(2),10);if(L(e.algorithm.hash)!==a)throw h(`SHA-${a}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!P(e.algorithm,"RSASSA-PKCS1-v1_5"))throw h("RSASSA-PKCS1-v1_5");const a=parseInt(t.slice(2),10);if(L(e.algorithm.hash)!==a)throw h(`SHA-${a}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!P(e.algorithm,"RSA-PSS"))throw h("RSA-PSS");const a=parseInt(t.slice(2),10);if(L(e.algorithm.hash)!==a)throw h(`SHA-${a}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!P(e.algorithm,"Ed25519"))throw h("Ed25519");break}case"ES256":case"ES384":case"ES512":{if(!P(e.algorithm,"ECDSA"))throw h("ECDSA");const a=Me(t);if(e.algorithm.namedCurve!==a)throw h(a,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}Be(e,r)}function ne(e,t,...r){var a;if(r=r.filter(Boolean),r.length>2){const s=r.pop();e+=`one of type ${r.join(", ")}, or ${s}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(a=t.constructor)!=null&&a.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const Le=(e,...t)=>ne("Key must be ",e,...t);function oe(e,t,...r){return ne(`Key for the ${e} algorithm must be `,t,...r)}function ie(e){return(e==null?void 0:e[Symbol.toStringTag])==="CryptoKey"}function ce(e){return(e==null?void 0:e[Symbol.toStringTag])==="KeyObject"}const de=e=>ie(e)||ce(e),Ve=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const a of t){const s=Object.keys(a);if(!r||r.size===0){r=new Set(s);continue}for(const n of s){if(r.has(n))return!1;r.add(n)}}return!0};function qe(e){return typeof e=="object"&&e!==null}const le=e=>{if(!qe(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t},Ge=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function Ye(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new b('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new b('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new b('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new b('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const ze=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=Ye(e),a={...e};return delete a.alg,delete a.use,crypto.subtle.importKey("jwk",a,t,e.ext??!e.d,e.key_ops??r)},Fe=(e,t,r,a,s)=>{if(s.crit!==void 0&&(a==null?void 0:a.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!a||a.crit===void 0)return new Set;if(!Array.isArray(a.crit)||a.crit.length===0||a.crit.some(o=>typeof o!="string"||o.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;r!==void 0?n=new Map([...Object.entries(r),...t.entries()]):n=t;for(const o of a.crit){if(!n.has(o))throw new b(`Extension Header Parameter "${o}" is not recognized`);if(s[o]===void 0)throw new e(`Extension Header Parameter "${o}" is missing`);if(n.get(o)&&a[o]===void 0)throw new e(`Extension Header Parameter "${o}" MUST be integrity protected`)}return new Set(a.crit)};function G(e){return le(e)&&typeof e.kty=="string"}function je(e){return e.kty!=="oct"&&typeof e.d=="string"}function Xe(e){return e.kty!=="oct"&&typeof e.d>"u"}function Ze(e){return e.kty==="oct"&&typeof e.k=="string"}let K;const k=async(e,t,r,a=!1)=>{K||(K=new WeakMap);let s=K.get(e);if(s!=null&&s[r])return s[r];const n=await ze({...t,alg:r});return a&&Object.freeze(e),s?s[r]=n:K.set(e,{[r]:n}),n},Qe=(e,t)=>{var o;K||(K=new WeakMap);let r=K.get(e);if(r!=null&&r[t])return r[t];const a=e.type==="public",s=!!a;let n;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}n=e.toCryptoKey(e.asymmetricKeyType,s,a?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");n=e.toCryptoKey(e.asymmetricKeyType,s,[a?"verify":"sign"])}if(e.asymmetricKeyType==="rsa"){let i;switch(t){case"RSA-OAEP":i="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":i="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":i="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":i="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:i},s,a?["encrypt"]:["decrypt"]);n=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:i},s,[a?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){const c=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get((o=e.asymmetricKeyDetails)==null?void 0:o.namedCurve);if(!c)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&c==="P-256"&&(n=e.toCryptoKey({name:"ECDSA",namedCurve:c},s,[a?"verify":"sign"])),t==="ES384"&&c==="P-384"&&(n=e.toCryptoKey({name:"ECDSA",namedCurve:c},s,[a?"verify":"sign"])),t==="ES512"&&c==="P-521"&&(n=e.toCryptoKey({name:"ECDSA",namedCurve:c},s,[a?"verify":"sign"])),t.startsWith("ECDH-ES")&&(n=e.toCryptoKey({name:"ECDH",namedCurve:c},s,a?[]:["deriveBits"]))}if(!n)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=n:K.set(e,{[t]:n}),n},ke=async(e,t)=>{if(e instanceof Uint8Array||ie(e))return e;if(ce(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return Qe(e,t)}catch(a){if(a instanceof TypeError)throw a}let r=e.export({format:"jwk"});return k(e,r,t)}if(G(e))return e.k?Ue(e.k):k(e,e,t,!0);throw new Error("unreachable")},A=e=>e==null?void 0:e[Symbol.toStringTag],q=(e,t,r)=>{var a,s;if(t.use!==void 0){let n;switch(r){case"sign":case"verify":n="sig";break;case"encrypt":case"decrypt":n="enc";break}if(t.use!==n)throw new TypeError(`Invalid key for this operation, its "use" must be "${n}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let n;switch(!0){case r==="sign":case e==="dir":case e.includes("CBC-HS"):n=r;break;case e.startsWith("PBES2"):n="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?n="unwrapKey":n=r;break;case r==="encrypt":n="wrapKey";break;case r==="decrypt":n=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(n&&((s=(a=t.key_ops)==null?void 0:a.includes)==null?void 0:s.call(a,n))===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${n}" when present`)}return!0},et=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(G(t)){if(Ze(t)&&q(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!de(t))throw new TypeError(oe(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${A(t)} instances for symmetric algorithms must be of type "secret"`)}},tt=(e,t,r)=>{if(G(t))switch(r){case"decrypt":case"sign":if(je(t)&&q(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"encrypt":case"verify":if(Xe(t)&&q(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!de(t))throw new TypeError(oe(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${A(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case"sign":throw new TypeError(`${A(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${A(t)} instances for asymmetric algorithm decryption must be of type "private"`)}if(t.type==="private")switch(r){case"verify":throw new TypeError(`${A(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${A(t)} instances for asymmetric algorithm encryption must be of type "public"`)}},rt=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(e)||/^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(e)?et(e,t,r):tt(e,t,r)},at=(e,t)=>{const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};default:throw new b(`alg ${e} is not supported either by JOSE or your javascript runtime`)}},st=async(e,t,r)=>{if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(Le(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}return Ne(t,e,r),t},m=e=>Math.floor(e.getTime()/1e3),ue=60,fe=ue*60,Y=fe*24,nt=Y*7,ot=Y*365.25,it=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,V=e=>{const t=it.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),a=t[3].toLowerCase();let s;switch(a){case"sec":case"secs":case"second":case"seconds":case"s":s=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":s=Math.round(r*ue);break;case"hour":case"hours":case"hr":case"hrs":case"h":s=Math.round(r*fe);break;case"day":case"days":case"d":s=Math.round(r*Y);break;case"week":case"weeks":case"w":s=Math.round(r*nt);break;default:s=Math.round(r*ot);break}return t[1]==="-"||t[4]==="ago"?-s:s},ct=async(e,t,r)=>{const a=await st(e,t,"sign");Ge(e,a);const s=await crypto.subtle.sign(at(e,a.algorithm),a,r);return new Uint8Array(s)};class dt{constructor(t){d(this,"_payload");d(this,"_protectedHeader");d(this,"_unprotectedHeader");if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new _("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!Ve(this._protectedHeader,this._unprotectedHeader))throw new _("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader},s=Fe(_,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,a);let n=!0;if(s.has("b64")&&(n=this._protectedHeader.b64,typeof n!="boolean"))throw new _('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:o}=a;if(typeof o!="string"||!o)throw new _('JWS "alg" (Algorithm) Header Parameter missing or invalid');rt(o,t,"sign");let i=this._payload;n&&(i=g.encode(N(i)));let c;this._protectedHeader?c=g.encode(N(JSON.stringify(this._protectedHeader))):c=g.encode("");const T=Oe(c,g.encode("."),i),C=await ke(t,o),w=await ct(o,C,T),y={signature:N(w),payload:""};return n&&(y.payload=O.decode(i)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=O.decode(c)),y}}class lt{constructor(t){d(this,"_flattened");this._flattened=new dt(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){const a=await this._flattened.sign(t,r);if(a.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${a.protected}.${a.payload}.${a.signature}`}}function S(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}class ut{constructor(t={}){d(this,"_payload");if(!le(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:S("setNotBefore",t)}:t instanceof Date?this._payload={...this._payload,nbf:S("setNotBefore",m(t))}:this._payload={...this._payload,nbf:m(new Date)+V(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:S("setExpirationTime",t)}:t instanceof Date?this._payload={...this._payload,exp:S("setExpirationTime",m(t))}:this._payload={...this._payload,exp:m(new Date)+V(t)},this}setIssuedAt(t){return typeof t>"u"?this._payload={...this._payload,iat:m(new Date)}:t instanceof Date?this._payload={...this._payload,iat:S("setIssuedAt",m(t))}:typeof t=="string"?this._payload={...this._payload,iat:S("setIssuedAt",m(new Date)+V(t))}:this._payload={...this._payload,iat:S("setIssuedAt",t)},this}}class ft extends ut{constructor(){super(...arguments);d(this,"_protectedHeader")}setProtectedHeader(r){return this._protectedHeader=r,this}async sign(r,a){var n;const s=new lt(g.encode(JSON.stringify(this._payload)));if(s.setProtectedHeader(this._protectedHeader),Array.isArray((n=this._protectedHeader)==null?void 0:n.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new se("JWTs MUST NOT use unencoded payload");return s.sign(r,a)}}function ht(e,t){let r=new Uint8Array(32);crypto.getRandomValues(r),t.secret=btoa(String.fromCharCode(...r))}var pt=ee('<div class="w-md card bg-base-100 shadow-xl p-2 mt-4"><div class="card-body"><pre class="whitespace-pre-wrap break-all"> </pre></div></div>'),yt=ee('<main><div class="hero bg-base-200 min-h-screen"><div class="hero-content text-center"><div><div class="w-md card bg-base-100 shadow-xl p-4"><h2 class="text-xl font-bold p-2">トークン生成</h2> <button class="btn mb-4">秘密鍵を生成する</button> <label class="input w-full mb-4 block"><iconify-icon></iconify-icon> <input type="text" class="grow" placeholder="秘密鍵"></label> <select class="select w-full mb-4"><option>エージェント</option><option>リアルタイムログ</option></select> <label class="input w-full mb-4 block"><iconify-icon></iconify-icon> <input type="text" class="grow" placeholder="チーム名"></label></div> <!></div></div></div></main>',2);function Kt(e,t){_e(t,!0);let r=We({secret:"",role:"PLAYER",team:"",token:""});Ae(()=>{a(r.secret,r.role,r.team)});async function a(l,v,x){if(!l||!v){r.token="";return}const $=v==="PLAYER"?{role:"PLAYER",team:x}:{role:"RECEIVER"};try{const D=new TextEncoder().encode(l),ye=await new ft($).setProtectedHeader({alg:"HS256"}).sign(D);r.token=ye}catch{r.token="エラーが発生しました"}}var s=yt();Te(l=>{Ke.title="aiwolf-nlp-viewer"});var n=u(s),o=u(n),i=u(o),c=u(i),T=p(u(c),2);T.__click=[ht,r];var C=p(T,2),w=u(C);E(w,"class","h-[1em] opacity-50"),E(w,"inline",!0),E(w,"icon","mdi:key");var y=p(w,2);Z(y),f(C);var R=p(C,2),I=u(R);I.value=(I.__value="PLAYER")==null?"":"PLAYER";var z=p(I);z.value=(z.__value="RECEIVER")==null?"":"RECEIVER",f(R);var F=p(R,2),W=u(F);E(W,"class","h-[1em] opacity-50"),E(W,"inline",!0),E(W,"icon","mdi:form-textbox");var U=p(W,2);Z(U),f(F),f(c);var he=p(c,2);{var pe=l=>{var v=pt(),x=u(v),$=u(x),D=u($,!0);f($),f(x),f(v),X(()=>Ce(D,r.token)),j(l,v)};Pe(he,l=>{r.token&&l(pe)})}f(i),f(o),f(n),f(s),X(()=>U.disabled=r.role!=="PLAYER"),Q(y,()=>r.secret,l=>r.secret=l),$e(R,()=>r.role,l=>r.role=l),Q(U,()=>r.team,l=>r.team=l),j(e,s),ge()}He(["click"]);export{Kt as component};
