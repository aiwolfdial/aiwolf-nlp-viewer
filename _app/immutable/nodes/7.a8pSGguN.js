import"../chunks/DsnmJJEf.js";import{p as Te,i as Re,au as He,f as he,s as h,d as o,t as ne,b as ie,c as We,r as c}from"../chunks/DO4nmVCp.js";import{d as xe,s as l}from"../chunks/ZvrJVx00.js";import{i as $e}from"../chunks/DunjnO_o.js";import{L as De,a as U,s as ae,r as oe}from"../chunks/BAzGqRan.js";import{s as ce}from"../chunks/BVXqbbjT.js";import{b as de}from"../chunks/VfUbFVkd.js";import{b as Je}from"../chunks/CYzPR3gv.js";import{a as Oe,s as Ie}from"../chunks/aJomyVap.js";import{$ as Ue}from"../chunks/IkSv0N2d.js";const K=new TextEncoder,B=new TextDecoder;function Be(...t){const e=t.reduce((n,{length:i})=>n+i,0),r=new Uint8Array(e);let s=0;for(const n of t)r.set(n,s),s+=n.length;return r}function Me(t){if(Uint8Array.prototype.toBase64)return t.toBase64();const e=32768,r=[];for(let s=0;s<t.length;s+=e)r.push(String.fromCharCode.apply(null,t.subarray(s,s+e)));return btoa(r.join(""))}function Ne(t){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(t);const e=atob(t),r=new Uint8Array(e.length);for(let s=0;s<e.length;s++)r[s]=e.charCodeAt(s);return r}function Le(t){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof t=="string"?t:B.decode(t),{alphabet:"base64url"});let e=t;e instanceof Uint8Array&&(e=B.decode(e)),e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Ne(e)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}function q(t){let e=t;return typeof e=="string"&&(e=K.encode(e)),Uint8Array.prototype.toBase64?e.toBase64({alphabet:"base64url",omitPadding:!0}):Me(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}class Q extends Error{static code="ERR_JOSE_GENERIC";code="ERR_JOSE_GENERIC";constructor(e,r){super(e,r),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class C extends Q{static code="ERR_JOSE_NOT_SUPPORTED";code="ERR_JOSE_NOT_SUPPORTED"}class R extends Q{static code="ERR_JWS_INVALID";code="ERR_JWS_INVALID"}class Ve extends Q{static code="ERR_JWT_INVALID";code="ERR_JWT_INVALID"}function p(t,e="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${e} must be ${t}`)}function H(t,e){return t.name===e}function F(t){return parseInt(t.name.slice(4),10)}function Ge(t){switch(t){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function Ye(t,e){if(!t.usages.includes(e))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${e}.`)}function je(t,e,r){switch(e){case"HS256":case"HS384":case"HS512":{if(!H(t.algorithm,"HMAC"))throw p("HMAC");const s=parseInt(e.slice(2),10);if(F(t.algorithm.hash)!==s)throw p(`SHA-${s}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!H(t.algorithm,"RSASSA-PKCS1-v1_5"))throw p("RSASSA-PKCS1-v1_5");const s=parseInt(e.slice(2),10);if(F(t.algorithm.hash)!==s)throw p(`SHA-${s}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!H(t.algorithm,"RSA-PSS"))throw p("RSA-PSS");const s=parseInt(e.slice(2),10);if(F(t.algorithm.hash)!==s)throw p(`SHA-${s}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!H(t.algorithm,"Ed25519"))throw p("Ed25519");break}case"ES256":case"ES384":case"ES512":{if(!H(t.algorithm,"ECDSA"))throw p("ECDSA");const s=Ge(e);if(t.algorithm.namedCurve!==s)throw p(s,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}Ye(t,r)}function fe(t,e,...r){if(r=r.filter(Boolean),r.length>2){const s=r.pop();t+=`one of type ${r.join(", ")}, or ${s}.`}else r.length===2?t+=`one of type ${r[0]} or ${r[1]}.`:t+=`of type ${r[0]}.`;return e==null?t+=` Received ${e}`:typeof e=="function"&&e.name?t+=` Received function ${e.name}`:typeof e=="object"&&e!=null&&e.constructor?.name&&(t+=` Received an instance of ${e.constructor.name}`),t}const ke=(t,...e)=>fe("Key must be ",t,...e);function pe(t,e,...r){return fe(`Key for the ${t} algorithm must be `,e,...r)}function le(t){return t?.[Symbol.toStringTag]==="CryptoKey"}function me(t){return t?.[Symbol.toStringTag]==="KeyObject"}const ye=t=>le(t)||me(t),ze=(...t)=>{const e=t.filter(Boolean);if(e.length===0||e.length===1)return!0;let r;for(const s of e){const n=Object.keys(s);if(!r||r.size===0){r=new Set(n);continue}for(const i of n){if(r.has(i))return!1;r.add(i)}}return!0};function qe(t){return typeof t=="object"&&t!==null}const Se=t=>{if(!qe(t)||Object.prototype.toString.call(t)!=="[object Object]")return!1;if(Object.getPrototypeOf(t)===null)return!0;let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e},Fe=(t,e)=>{if(t.startsWith("RS")||t.startsWith("PS")){const{modulusLength:r}=e.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${t} requires key modulusLength to be 2048 bits or larger`)}};function Xe(t){let e,r;switch(t.kty){case"RSA":{switch(t.alg){case"PS256":case"PS384":case"PS512":e={name:"RSA-PSS",hash:`SHA-${t.alg.slice(-3)}`},r=t.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":e={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${t.alg.slice(-3)}`},r=t.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":e={name:"RSA-OAEP",hash:`SHA-${parseInt(t.alg.slice(-3),10)||1}`},r=t.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new C('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(t.alg){case"ES256":e={name:"ECDSA",namedCurve:"P-256"},r=t.d?["sign"]:["verify"];break;case"ES384":e={name:"ECDSA",namedCurve:"P-384"},r=t.d?["sign"]:["verify"];break;case"ES512":e={name:"ECDSA",namedCurve:"P-521"},r=t.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":e={name:"ECDH",namedCurve:t.crv},r=t.d?["deriveBits"]:[];break;default:throw new C('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(t.alg){case"Ed25519":case"EdDSA":e={name:"Ed25519"},r=t.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":e={name:t.crv},r=t.d?["deriveBits"]:[];break;default:throw new C('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new C('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:e,keyUsages:r}}const Ze=async t=>{if(!t.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:e,keyUsages:r}=Xe(t),s={...t};return delete s.alg,delete s.use,crypto.subtle.importKey("jwk",s,e,t.ext??!t.d,t.key_ops??r)},Qe=(t,e,r,s,n)=>{if(n.crit!==void 0&&s?.crit===void 0)throw new t('"crit" (Critical) Header Parameter MUST be integrity protected');if(!s||s.crit===void 0)return new Set;if(!Array.isArray(s.crit)||s.crit.length===0||s.crit.some(a=>typeof a!="string"||a.length===0))throw new t('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;r!==void 0?i=new Map([...Object.entries(r),...e.entries()]):i=e;for(const a of s.crit){if(!i.has(a))throw new C(`Extension Header Parameter "${a}" is not recognized`);if(n[a]===void 0)throw new t(`Extension Header Parameter "${a}" is missing`);if(i.get(a)&&s[a]===void 0)throw new t(`Extension Header Parameter "${a}" MUST be integrity protected`)}return new Set(s.crit)};function ee(t){return Se(t)&&typeof t.kty=="string"}function et(t){return t.kty!=="oct"&&typeof t.d=="string"}function tt(t){return t.kty!=="oct"&&typeof t.d>"u"}function rt(t){return t.kty==="oct"&&typeof t.k=="string"}let P;const ue=async(t,e,r,s=!1)=>{P||=new WeakMap;let n=P.get(t);if(n?.[r])return n[r];const i=await Ze({...e,alg:r});return s&&Object.freeze(t),n?n[r]=i:P.set(t,{[r]:i}),i},st=(t,e)=>{P||=new WeakMap;let r=P.get(t);if(r?.[e])return r[e];const s=t.type==="public",n=!!s;let i;if(t.asymmetricKeyType==="x25519"){switch(e){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}i=t.toCryptoKey(t.asymmetricKeyType,n,s?[]:["deriveBits"])}if(t.asymmetricKeyType==="ed25519"){if(e!=="EdDSA"&&e!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=t.toCryptoKey(t.asymmetricKeyType,n,[s?"verify":"sign"])}if(t.asymmetricKeyType==="rsa"){let a;switch(e){case"RSA-OAEP":a="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":a="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":a="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":a="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(e.startsWith("RSA-OAEP"))return t.toCryptoKey({name:"RSA-OAEP",hash:a},n,s?["encrypt"]:["decrypt"]);i=t.toCryptoKey({name:e.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:a},n,[s?"verify":"sign"])}if(t.asymmetricKeyType==="ec"){const d=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get(t.asymmetricKeyDetails?.namedCurve);if(!d)throw new TypeError("given KeyObject instance cannot be used for this algorithm");e==="ES256"&&d==="P-256"&&(i=t.toCryptoKey({name:"ECDSA",namedCurve:d},n,[s?"verify":"sign"])),e==="ES384"&&d==="P-384"&&(i=t.toCryptoKey({name:"ECDSA",namedCurve:d},n,[s?"verify":"sign"])),e==="ES512"&&d==="P-521"&&(i=t.toCryptoKey({name:"ECDSA",namedCurve:d},n,[s?"verify":"sign"])),e.startsWith("ECDH-ES")&&(i=t.toCryptoKey({name:"ECDH",namedCurve:d},n,s?[]:["deriveBits"]))}if(!i)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[e]=i:P.set(t,{[e]:i}),i},nt=async(t,e)=>{if(t instanceof Uint8Array||le(t))return t;if(me(t)){if(t.type==="secret")return t.export();if("toCryptoKey"in t&&typeof t.toCryptoKey=="function")try{return st(t,e)}catch(s){if(s instanceof TypeError)throw s}let r=t.export({format:"jwk"});return ue(t,r,e)}if(ee(t))return t.k?Le(t.k):ue(t,t,e,!0);throw new Error("unreachable")},A=t=>t?.[Symbol.toStringTag],Z=(t,e,r)=>{if(e.use!==void 0){let s;switch(r){case"sign":case"verify":s="sig";break;case"encrypt":case"decrypt":s="enc";break}if(e.use!==s)throw new TypeError(`Invalid key for this operation, its "use" must be "${s}" when present`)}if(e.alg!==void 0&&e.alg!==t)throw new TypeError(`Invalid key for this operation, its "alg" must be "${t}" when present`);if(Array.isArray(e.key_ops)){let s;switch(!0){case r==="sign":case t==="dir":case t.includes("CBC-HS"):s=r;break;case t.startsWith("PBES2"):s="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(t):!t.includes("GCM")&&t.endsWith("KW")?s="unwrapKey":s=r;break;case r==="encrypt":s="wrapKey";break;case r==="decrypt":s=t.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(s&&e.key_ops?.includes?.(s)===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${s}" when present`)}return!0},it=(t,e,r)=>{if(!(e instanceof Uint8Array)){if(ee(e)){if(rt(e)&&Z(t,e,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!ye(e))throw new TypeError(pe(t,e,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(e.type!=="secret")throw new TypeError(`${A(e)} instances for symmetric algorithms must be of type "secret"`)}},at=(t,e,r)=>{if(ee(e))switch(r){case"decrypt":case"sign":if(et(e)&&Z(t,e,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"encrypt":case"verify":if(tt(e)&&Z(t,e,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!ye(e))throw new TypeError(pe(t,e,"CryptoKey","KeyObject","JSON Web Key"));if(e.type==="secret")throw new TypeError(`${A(e)} instances for asymmetric algorithms must not be of type "secret"`);if(e.type==="public")switch(r){case"sign":throw new TypeError(`${A(e)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${A(e)} instances for asymmetric algorithm decryption must be of type "private"`)}if(e.type==="private")switch(r){case"verify":throw new TypeError(`${A(e)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${A(e)} instances for asymmetric algorithm encryption must be of type "public"`)}},ot=(t,e,r)=>{t.startsWith("HS")||t==="dir"||t.startsWith("PBES2")||/^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(t)||/^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(t)?it(t,e,r):at(t,e,r)},ct=(t,e)=>{const r=`SHA-${t.slice(-3)}`;switch(t){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(t.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:e.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};default:throw new C(`alg ${t} is not supported either by JOSE or your javascript runtime`)}},dt=async(t,e,r)=>{if(e instanceof Uint8Array){if(!t.startsWith("HS"))throw new TypeError(ke(e,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",e,{hash:`SHA-${t.slice(-3)}`,name:"HMAC"},!1,[r])}return je(e,t,r),e},E=t=>Math.floor(t.getTime()/1e3),be=60,we=be*60,te=we*24,ut=te*7,ht=te*365.25,ft=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,X=t=>{const e=ft.exec(t);if(!e||e[4]&&e[1])throw new TypeError("Invalid time period format");const r=parseFloat(e[2]),s=e[3].toLowerCase();let n;switch(s){case"sec":case"secs":case"second":case"seconds":case"s":n=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":n=Math.round(r*be);break;case"hour":case"hours":case"hr":case"hrs":case"h":n=Math.round(r*we);break;case"day":case"days":case"d":n=Math.round(r*te);break;case"week":case"weeks":case"w":n=Math.round(r*ut);break;default:n=Math.round(r*ht);break}return e[1]==="-"||e[4]==="ago"?-n:n};function v(t,e){if(!Number.isFinite(e))throw new TypeError(`Invalid ${t} input`);return e}class pt{#e;constructor(e){if(!Se(e))throw new TypeError("JWT Claims Set MUST be an object");this.#e=structuredClone(e)}data(){return K.encode(JSON.stringify(this.#e))}get iss(){return this.#e.iss}set iss(e){this.#e.iss=e}get sub(){return this.#e.sub}set sub(e){this.#e.sub=e}get aud(){return this.#e.aud}set aud(e){this.#e.aud=e}set jti(e){this.#e.jti=e}set nbf(e){typeof e=="number"?this.#e.nbf=v("setNotBefore",e):e instanceof Date?this.#e.nbf=v("setNotBefore",E(e)):this.#e.nbf=E(new Date)+X(e)}set exp(e){typeof e=="number"?this.#e.exp=v("setExpirationTime",e):e instanceof Date?this.#e.exp=v("setExpirationTime",E(e)):this.#e.exp=E(new Date)+X(e)}set iat(e){typeof e>"u"?this.#e.iat=E(new Date):e instanceof Date?this.#e.iat=v("setIssuedAt",E(e)):typeof e=="string"?this.#e.iat=v("setIssuedAt",E(new Date)+X(e)):this.#e.iat=v("setIssuedAt",e)}}const lt=async(t,e,r)=>{const s=await dt(t,e,"sign");Fe(t,s);const n=await crypto.subtle.sign(ct(t,s.algorithm),s,r);return new Uint8Array(n)};class mt{#e;#t;#r;constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this.#e=e}setProtectedHeader(e){if(this.#t)throw new TypeError("setProtectedHeader can only be called once");return this.#t=e,this}setUnprotectedHeader(e){if(this.#r)throw new TypeError("setUnprotectedHeader can only be called once");return this.#r=e,this}async sign(e,r){if(!this.#t&&!this.#r)throw new R("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!ze(this.#t,this.#r))throw new R("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const s={...this.#t,...this.#r},n=Qe(R,new Map([["b64",!0]]),r?.crit,this.#t,s);let i=!0;if(n.has("b64")&&(i=this.#t.b64,typeof i!="boolean"))throw new R('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:a}=s;if(typeof a!="string"||!a)throw new R('JWS "alg" (Algorithm) Header Parameter missing or invalid');ot(a,e,"sign");let d=this.#e;i&&(d=K.encode(q(d)));let m;this.#t?m=K.encode(q(JSON.stringify(this.#t))):m=K.encode("");const W=Be(m,K.encode("."),d),_=await nt(e,a),M=await lt(a,_,W),y={signature:q(M),payload:""};return i&&(y.payload=B.decode(d)),this.#r&&(y.header=this.#r),this.#t&&(y.protected=B.decode(m)),y}}class yt{#e;constructor(e){this.#e=new mt(e)}setProtectedHeader(e){return this.#e.setProtectedHeader(e),this}async sign(e,r){const s=await this.#e.sign(e,r);if(s.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${s.protected}.${s.payload}.${s.signature}`}}class St{#e;#t;constructor(e={}){this.#t=new pt(e)}setIssuer(e){return this.#t.iss=e,this}setSubject(e){return this.#t.sub=e,this}setAudience(e){return this.#t.aud=e,this}setJti(e){return this.#t.jti=e,this}setNotBefore(e){return this.#t.nbf=e,this}setExpirationTime(e){return this.#t.exp=e,this}setIssuedAt(e){return this.#t.iat=e,this}setProtectedHeader(e){return this.#e=e,this}async sign(e,r){const s=new yt(this.#t.data());if(s.setProtectedHeader(this.#e),Array.isArray(this.#e?.crit)&&this.#e.crit.includes("b64")&&this.#e.b64===!1)throw new Ve("JWTs MUST NOT use unencoded payload");return s.sign(e,r)}}function bt(t,e){let r=new Uint8Array(32);crypto.getRandomValues(r),e.secret=btoa(String.fromCharCode(...r))}var wt=(t,e)=>navigator.clipboard.writeText(e.token),Et=he('<div class="w-md card bg-base-100 shadow-xl mt-4"><div class="card-body"><pre class="whitespace-pre-wrap break-all"> </pre> <button class="btn"> </button></div></div>'),vt=he('<main><div class="hero bg-base-200 min-h-screen"><div class="hero-content"><div class="absolute top-4 right-4"><!></div> <div><div class="w-md card bg-base-100 shadow-xl"><div class="card-body"><h2 class="text-xl font-bold text-center"> </h2> <p class="text-sm"> </p> <p class="text-sm"> </p> <button class="btn mt-2"> </button> <label class="input w-full mt-2 block"><iconify-icon></iconify-icon> <input type="text" class="grow"/></label> <select class="select w-full mt-2"><option> </option><option> </option></select> <label class="input w-full mt-2 block"><iconify-icon></iconify-icon> <input type="text" class="grow"/></label></div></div> <!></div></div></div></main>',2);function xt(t,e){Te(e,!0);const[r,s]=Ie(),n=()=>Oe(Ue,"$_",r);let i=Re({secret:"",role:"PLAYER",team:"",token:""});He(()=>{a(i.secret,i.role,i.team)});async function a(u,f,S){if(!u||!f){i.token="";return}if(f==="PLAYER"&&!S){i.token="";return}const b=f==="PLAYER"?{role:"PLAYER",team:S}:{role:"RECEIVER"};try{const g=new TextEncoder().encode(u),w=await new St(b).setProtectedHeader({alg:"HS256"}).sign(g);i.token=w}catch{i.token=n()("token.errorOccurred")}}var d=vt(),m=o(d),W=o(m),_=o(W),M=o(_);De(M,{}),c(_);var y=h(_,2),N=o(y),re=o(N),L=o(re),Ee=o(L,!0);c(L);var V=h(L,2),ve=o(V,!0);c(V);var G=h(V,2),ge=o(G,!0);c(G);var x=h(G,2);x.__click=[bt,i];var Ae=o(x,!0);c(x);var Y=h(x,2),$=o(Y);ce($,1,"h-[1em] opacity-50"),U($,"inline",!0),U($,"icon","mdi:key");var j=h($,2);oe(j),c(Y);var D=h(Y,2),T=o(D),Ke=o(T,!0);c(T),T.value=T.__value="PLAYER";var J=h(T),Ce=o(J,!0);c(J),J.value=J.__value="RECEIVER",c(D);var se=h(D,2),O=o(se);ce(O,1,"h-[1em] opacity-50"),U(O,"inline",!0),U(O,"icon","mdi:form-textbox");var I=h(O,2);oe(I),c(se),c(re),c(N);var Pe=h(N,2);{var _e=u=>{var f=Et(),S=o(f),b=o(S),g=o(b,!0);c(b);var w=h(b,2);w.__click=[wt,i];var k=o(w,!0);c(w),c(S),c(f),ne(z=>{l(g,i.token),l(k,z)},[()=>n()("token.copyToken")]),ie(u,f)};$e(Pe,u=>{i.token&&u(_e)})}c(y),c(W),c(m),c(d),ne((u,f,S,b,g,w,k,z)=>{l(Ee,u),l(ve,f),l(ge,S),l(Ae,b),ae(j,"placeholder",g),l(Ke,w),l(Ce,k),ae(I,"placeholder",z),I.disabled=i.role!=="PLAYER"},[()=>n()("token.title"),()=>n()("token.description"),()=>n()("token.agentDescription"),()=>n()("token.generateSecret"),()=>n()("token.secretKey"),()=>n()("token.agent"),()=>n()("token.realtimeLog"),()=>n()("token.teamName")]),de(j,()=>i.secret,u=>i.secret=u),Je(D,()=>i.role,u=>i.role=u),de(I,()=>i.team,u=>i.team=u),ie(t,d),We(),s()}xe(["click"]);export{xt as component};
