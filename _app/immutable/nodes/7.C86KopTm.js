var he=Object.defineProperty;var pe=(e,t,r)=>t in e?he(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var d=(e,t,r)=>pe(e,typeof t!="symbol"?t+"":t,r);import{t as k,a as F}from"../chunks/HViqgMOa.js";import{p as fe,l as ue,h as u,c as h,i as j,a as ye,$ as me,f as p}from"../chunks/DVw0lqtx.js";import{d as Se,s as we}from"../chunks/D2z9SdKz.js";import{i as be}from"../chunks/Iz7RvOh6.js";import{h as Ee}from"../chunks/CmhqFjS7.js";import{a as E,r as X}from"../chunks/EUBOkeHQ.js";import{b as Z}from"../chunks/CBoNgZLI.js";import{b as _e}from"../chunks/CiU6qsmI.js";import{p as ve}from"../chunks/CS0_dE9u.js";/* empty css                */const A=new TextEncoder,D=new TextDecoder;function Ae(...e){const t=e.reduce((a,{length:n})=>a+n,0),r=new Uint8Array(t);let s=0;for(const a of e)r.set(a,s),s+=a.length;return r}function ge(e){if(Uint8Array.prototype.toBase64)return e.toBase64();const t=32768,r=[];for(let s=0;s<e.length;s+=t)r.push(String.fromCharCode.apply(null,e.subarray(s,s+t)));return btoa(r.join(""))}function Ke(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);const t=atob(e),r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return r}function Pe(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:D.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=D.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Ke(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}function B(e){let t=e;return typeof t=="string"&&(t=A.encode(t)),Uint8Array.prototype.toBase64?t.toBase64({alphabet:"base64url",omitPadding:!0}):ge(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}class J extends Error{constructor(r,s){var a;super(r,s);d(this,"code","ERR_JOSE_GENERIC");this.name=this.constructor.name,(a=Error.captureStackTrace)==null||a.call(Error,this,this.constructor)}}d(J,"code","ERR_JOSE_GENERIC");class b extends J{constructor(){super(...arguments);d(this,"code","ERR_JOSE_NOT_SUPPORTED")}}d(b,"code","ERR_JOSE_NOT_SUPPORTED");class _ extends J{constructor(){super(...arguments);d(this,"code","ERR_JWS_INVALID")}}d(_,"code","ERR_JWS_INVALID");class ee extends J{constructor(){super(...arguments);d(this,"code","ERR_JWT_INVALID")}}d(ee,"code","ERR_JWT_INVALID");function y(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function H(e,t){return e.name===t}function M(e){return parseInt(e.name.slice(4),10)}function Ce(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function He(e,t){if(!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function Te(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!H(e.algorithm,"HMAC"))throw y("HMAC");const s=parseInt(t.slice(2),10);if(M(e.algorithm.hash)!==s)throw y(`SHA-${s}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!H(e.algorithm,"RSASSA-PKCS1-v1_5"))throw y("RSASSA-PKCS1-v1_5");const s=parseInt(t.slice(2),10);if(M(e.algorithm.hash)!==s)throw y(`SHA-${s}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!H(e.algorithm,"RSA-PSS"))throw y("RSA-PSS");const s=parseInt(t.slice(2),10);if(M(e.algorithm.hash)!==s)throw y(`SHA-${s}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!H(e.algorithm,"Ed25519"))throw y("Ed25519");break}case"ES256":case"ES384":case"ES512":{if(!H(e.algorithm,"ECDSA"))throw y("ECDSA");const s=Ce(t);if(e.algorithm.namedCurve!==s)throw y(s,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}He(e,r)}function te(e,t,...r){var s;if(r=r.filter(Boolean),r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(s=t.constructor)!=null&&s.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const Re=(e,...t)=>te("Key must be ",e,...t);function re(e,t,...r){return te(`Key for the ${e} algorithm must be `,t,...r)}function se(e){return(e==null?void 0:e[Symbol.toStringTag])==="CryptoKey"}function ae(e){return(e==null?void 0:e[Symbol.toStringTag])==="KeyObject"}const ne=e=>se(e)||ae(e),We=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const s of t){const a=Object.keys(s);if(!r||r.size===0){r=new Set(a);continue}for(const n of a){if(r.has(n))return!1;r.add(n)}}return!0};function xe(e){return typeof e=="object"&&e!==null}const oe=e=>{if(!xe(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t},$e=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function De(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new b('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new b('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new b('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new b('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const Je=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=De(e),s={...e};return delete s.alg,delete s.use,crypto.subtle.importKey("jwk",s,t,e.ext??!e.d,e.key_ops??r)},Oe=(e,t,r,s,a)=>{if(a.crit!==void 0&&(s==null?void 0:s.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!s||s.crit===void 0)return new Set;if(!Array.isArray(s.crit)||s.crit.length===0||s.crit.some(o=>typeof o!="string"||o.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;r!==void 0?n=new Map([...Object.entries(r),...t.entries()]):n=t;for(const o of s.crit){if(!n.has(o))throw new b(`Extension Header Parameter "${o}" is not recognized`);if(a[o]===void 0)throw new e(`Extension Header Parameter "${o}" is missing`);if(n.get(o)&&s[o]===void 0)throw new e(`Extension Header Parameter "${o}" MUST be integrity protected`)}return new Set(s.crit)};function V(e){return oe(e)&&typeof e.kty=="string"}function Ie(e){return e.kty!=="oct"&&typeof e.d=="string"}function Ue(e){return e.kty!=="oct"&&typeof e.d>"u"}function Be(e){return e.kty==="oct"&&typeof e.k=="string"}let g;const Q=async(e,t,r,s=!1)=>{g||(g=new WeakMap);let a=g.get(e);if(a!=null&&a[r])return a[r];const n=await Je({...t,alg:r});return s&&Object.freeze(e),a?a[r]=n:g.set(e,{[r]:n}),n},Me=(e,t)=>{var o;g||(g=new WeakMap);let r=g.get(e);if(r!=null&&r[t])return r[t];const s=e.type==="public",a=!!s;let n;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}n=e.toCryptoKey(e.asymmetricKeyType,a,s?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");n=e.toCryptoKey(e.asymmetricKeyType,a,[s?"verify":"sign"])}if(e.asymmetricKeyType==="rsa"){let c;switch(t){case"RSA-OAEP":c="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":c="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":c="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":c="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:c},a,s?["encrypt"]:["decrypt"]);n=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:c},a,[s?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){const i=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get((o=e.asymmetricKeyDetails)==null?void 0:o.namedCurve);if(!i)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&i==="P-256"&&(n=e.toCryptoKey({name:"ECDSA",namedCurve:i},a,[s?"verify":"sign"])),t==="ES384"&&i==="P-384"&&(n=e.toCryptoKey({name:"ECDSA",namedCurve:i},a,[s?"verify":"sign"])),t==="ES512"&&i==="P-521"&&(n=e.toCryptoKey({name:"ECDSA",namedCurve:i},a,[s?"verify":"sign"])),t.startsWith("ECDH-ES")&&(n=e.toCryptoKey({name:"ECDH",namedCurve:i},a,s?[]:["deriveBits"]))}if(!n)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=n:g.set(e,{[t]:n}),n},Ne=async(e,t)=>{if(e instanceof Uint8Array||se(e))return e;if(ae(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return Me(e,t)}catch(s){if(s instanceof TypeError)throw s}let r=e.export({format:"jwk"});return Q(e,r,t)}if(V(e))return e.k?Pe(e.k):Q(e,e,t,!0);throw new Error("unreachable")},v=e=>e==null?void 0:e[Symbol.toStringTag],L=(e,t,r)=>{var s,a;if(t.use!==void 0){let n;switch(r){case"sign":case"verify":n="sig";break;case"encrypt":case"decrypt":n="enc";break}if(t.use!==n)throw new TypeError(`Invalid key for this operation, its "use" must be "${n}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let n;switch(!0){case r==="sign":case e==="dir":case e.includes("CBC-HS"):n=r;break;case e.startsWith("PBES2"):n="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?n="unwrapKey":n=r;break;case r==="encrypt":n="wrapKey";break;case r==="decrypt":n=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(n&&((a=(s=t.key_ops)==null?void 0:s.includes)==null?void 0:a.call(s,n))===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${n}" when present`)}return!0},Le=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(V(t)){if(Be(t)&&L(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!ne(t))throw new TypeError(re(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${v(t)} instances for symmetric algorithms must be of type "secret"`)}},Ve=(e,t,r)=>{if(V(t))switch(r){case"decrypt":case"sign":if(Ie(t)&&L(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"encrypt":case"verify":if(Ue(t)&&L(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!ne(t))throw new TypeError(re(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${v(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case"sign":throw new TypeError(`${v(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${v(t)} instances for asymmetric algorithm decryption must be of type "private"`)}if(t.type==="private")switch(r){case"verify":throw new TypeError(`${v(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${v(t)} instances for asymmetric algorithm encryption must be of type "public"`)}},Ye=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(e)||/^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(e)?Le(e,t,r):Ve(e,t,r)},Ge=(e,t)=>{const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};default:throw new b(`alg ${e} is not supported either by JOSE or your javascript runtime`)}},ze=async(e,t,r)=>{if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(Re(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}return Te(t,e,r),t},S=e=>Math.floor(e.getTime()/1e3),ie=60,ce=ie*60,Y=ce*24,qe=Y*7,Fe=Y*365.25,je=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,N=e=>{const t=je.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),s=t[3].toLowerCase();let a;switch(s){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*ie);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*ce);break;case"day":case"days":case"d":a=Math.round(r*Y);break;case"week":case"weeks":case"w":a=Math.round(r*qe);break;default:a=Math.round(r*Fe);break}return t[1]==="-"||t[4]==="ago"?-a:a},Xe=async(e,t,r)=>{const s=await ze(e,t,"sign");$e(e,s);const a=await crypto.subtle.sign(Ge(e,s.algorithm),s,r);return new Uint8Array(a)};class Ze{constructor(t){d(this,"_payload");d(this,"_protectedHeader");d(this,"_unprotectedHeader");if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new _("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!We(this._protectedHeader,this._unprotectedHeader))throw new _("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const s={...this._protectedHeader,...this._unprotectedHeader},a=Oe(_,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,s);let n=!0;if(a.has("b64")&&(n=this._protectedHeader.b64,typeof n!="boolean"))throw new _('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:o}=s;if(typeof o!="string"||!o)throw new _('JWS "alg" (Algorithm) Header Parameter missing or invalid');Ye(o,t,"sign");let c=this._payload;n&&(c=A.encode(B(c)));let i;this._protectedHeader?i=A.encode(B(JSON.stringify(this._protectedHeader))):i=A.encode("");const T=Ae(i,A.encode("."),c),R=await Ne(t,o),K=await Xe(o,R,T),f={signature:B(K),payload:""};return n&&(f.payload=D.decode(c)),this._unprotectedHeader&&(f.header=this._unprotectedHeader),this._protectedHeader&&(f.protected=D.decode(i)),f}}class Qe{constructor(t){d(this,"_flattened");this._flattened=new Ze(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){const s=await this._flattened.sign(t,r);if(s.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${s.protected}.${s.payload}.${s.signature}`}}function w(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}class ke{constructor(t={}){d(this,"_payload");if(!oe(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:w("setNotBefore",t)}:t instanceof Date?this._payload={...this._payload,nbf:w("setNotBefore",S(t))}:this._payload={...this._payload,nbf:S(new Date)+N(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:w("setExpirationTime",t)}:t instanceof Date?this._payload={...this._payload,exp:w("setExpirationTime",S(t))}:this._payload={...this._payload,exp:S(new Date)+N(t)},this}setIssuedAt(t){return typeof t>"u"?this._payload={...this._payload,iat:S(new Date)}:t instanceof Date?this._payload={...this._payload,iat:w("setIssuedAt",S(t))}:typeof t=="string"?this._payload={...this._payload,iat:w("setIssuedAt",S(new Date)+N(t))}:this._payload={...this._payload,iat:w("setIssuedAt",t)},this}}class et extends ke{constructor(){super(...arguments);d(this,"_protectedHeader")}setProtectedHeader(r){return this._protectedHeader=r,this}async sign(r,s){var n;const a=new Qe(A.encode(JSON.stringify(this._payload)));if(a.setProtectedHeader(this._protectedHeader),Array.isArray((n=this._protectedHeader)==null?void 0:n.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new ee("JWTs MUST NOT use unencoded payload");return a.sign(r,s)}}function tt(e,t){let r=new Uint8Array(32);crypto.getRandomValues(r),t.secret=btoa(String.fromCharCode(...r))}var rt=(e,t)=>navigator.clipboard.writeText(t.token),st=k('<div class="w-md card bg-base-100 shadow-xl mt-4"><div class="card-body"><pre class="whitespace-pre-wrap break-all"> </pre> <button class="btn">トークンをコピーする</button></div></div>'),at=k('<main><div class="hero bg-base-200 min-h-screen"><div class="hero-content"><div><div class="w-md card bg-base-100 shadow-xl"><div class="card-body"><h2 class="text-xl font-bold text-center">トークン生成</h2> <p class="text-sm">対戦サーバにおける接続認証を有効にした場合に必要となるトークンを生成します。秘密鍵はブラウザ上で生成され、サーバには一切送信されません。</p> <p class="text-sm">エージェントとして接続する場合は、チーム名を入力してください。</p> <button class="btn mt-2">秘密鍵を生成する</button> <label class="input w-full mt-2 block"><iconify-icon></iconify-icon> <input type="text" class="grow" placeholder="秘密鍵"></label> <select class="select w-full mt-2"><option>エージェント</option><option>リアルタイムログ</option></select> <label class="input w-full mt-2 block"><iconify-icon></iconify-icon> <input type="text" class="grow" placeholder="チーム名"></label></div></div> <!></div></div></div></main>',2);function mt(e,t){fe(t,!0);let r=ve({secret:"",role:"PLAYER",team:"",token:""});ue(()=>{s(r.secret,r.role,r.team)});async function s(l,m,P){if(!l||!m){r.token="";return}if(m==="PLAYER"&&!P){r.token="";return}const C=m==="PLAYER"?{role:"PLAYER",team:P}:{role:"RECEIVER"};try{const $=new TextEncoder().encode(l),U=await new et(C).setProtectedHeader({alg:"HS256"}).sign($);r.token=U}catch{r.token="エラーが発生しました"}}var a=at();Ee(l=>{me.title="aiwolf-nlp-viewer"});var n=h(a),o=h(n),c=h(o),i=h(c),T=h(i),R=u(h(T),6);R.__click=[tt,r];var K=u(R,2),f=h(K);E(f,"class","h-[1em] opacity-50"),E(f,"inline",!0),E(f,"icon","mdi:key");var G=u(f,2);X(G),p(K);var W=u(K,2),O=h(W);O.value=(O.__value="PLAYER")==null?"":"PLAYER";var z=u(O);z.value=(z.__value="RECEIVER")==null?"":"RECEIVER",p(W);var q=u(W,2),x=h(q);E(x,"class","h-[1em] opacity-50"),E(x,"inline",!0),E(x,"icon","mdi:form-textbox");var I=u(x,2);X(I),p(q),p(T),p(i);var de=u(i,2);{var le=l=>{var m=st(),P=h(m),C=h(P),$=h(C,!0);p(C);var U=u(C,2);U.__click=[rt,r],p(P),p(m),j(()=>we($,r.token)),F(l,m)};be(de,l=>{r.token&&l(le)})}p(c),p(o),p(n),p(a),j(()=>I.disabled=r.role!=="PLAYER"),Z(G,()=>r.secret,l=>r.secret=l),_e(W,()=>r.role,l=>r.role=l),Z(I,()=>r.team,l=>r.team=l),F(e,a),ye()}Se(["click"]);export{mt as component};
